/**
 *
 */
package de.tub.ise.hermes;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * receives messages over the network and distributes them to the appropriate
 * handlers
 *
 * @author David Bermbach
 *         <p>
 *         created on: 24.04.2012
 */
public class Receiver extends Thread {

    private static final Logger log = LoggerFactory.getLogger(Receiver.class);

    /* success and error messages */
    private static final String NO_HANDLER_FOUND = "The specified handler is unknown.";
    private static final String SUCCESS = "Auto OK, generated by Receiver.";
    /**
     * holds all active sockets that have not been read yet
     */
    private static final Queue<SocketPackage> unreadSockets = new LinkedList<SocketPackage>();
    /**
     * holds the keys of entries in unhandledRequests
     */
    private static final Queue<Integer> requests = new LinkedList<Integer>();
    /**
     * holds the keys of entries in unhandledRequests. Entries in this list will
     * be prioritized over entries in list requests. Prioritization is
     * determined based on the result of {@link IRequestHandler}.hasPriority()
     */
    private static final Queue<Integer> priorityRequests = new LinkedList<Integer>();
    /**
     * holds the keys of entries in waitingResponses
     */
    private static final Queue<Integer> responses = new LinkedList<Integer>();
    /**
     * holds all active sockets that are waiting for a response, key is the hash
     * of the corresponding request
     */
    private static final HashMap<Integer, SocketPackage> waitingSockets = new HashMap<Integer, SocketPackage>();
    /**
     * holds all requests which have been read from a socket but that have not
     * yet been processed by an {@link IRequestHandler}. Key is the hash of the
     * request
     */
    private static final HashMap<Integer, Request> unhandledRequests = new HashMap<Integer, Request>();
    /**
     * holds all finished responses that need to be written back via the socket.
     * key is the hash of the corresponding request
     */
    private static final HashMap<Integer, Response> waitingResponses = new HashMap<Integer, Response>();
    /**
     * server side socket
     */
    private ServerSocket serverSocket;
    /**
     * determines how many threads will be busy reading from networks
     */
    private int numberOfNetworkIOHandlers = 10;
    /**
     * determines how many threads will be busy invoking implementations of
     * {@link IRequestHandler}
     */
    private int numberOfRequestHandlers = 30;

    /**
     * @param port where shall the receiver listen for requests
     * @throws IOException if e.g., the port was already taken (if an I/O error occurs
     *                     when opening the socket)
     */
    public Receiver(int port) throws IOException {
        serverSocket = new ServerSocket(port);
        log.info("Receiver created at port " + port);
    }

    /**
     * @param port                      where shall the receiver listen for requests
     * @param numberOfNetworkIOHandlers determines how many threads will be busy reading from networks
     * @param numberOfRequestHandlers   determines how many threads will be busy invoking
     *                                  implementations of {@link IRequestHandler}
     * @throws IOException if e.g., the port was already taken (if an I/O error occurs
     *                     when opening the socket)
     */
    public Receiver(int port, int numberOfNetworkIOHandlers,
                    int numberOfRequestHandlers) throws IOException {
        this(port);
        if (numberOfNetworkIOHandlers > 0)
            this.numberOfNetworkIOHandlers = numberOfNetworkIOHandlers;
        if (numberOfRequestHandlers > 0)
            this.numberOfRequestHandlers = numberOfRequestHandlers;

    }

    @Override
    public void run() {
        log.info("Receiver is now running.");
        RequestHandlerRegistry.getInstance().printHandlers();
        new ThreadScaleManager().start();
        while (!isInterrupted()) {
            try {
                Socket s = serverSocket.accept();
                log.debug("new connection created to "
                        + s.getInetAddress().getHostAddress()
                        + " at port " + s.getLocalPort() + ":"
                        + new Date().getTime());
                SocketPackage soc = new SocketPackage();
                soc.socket = s;
                soc.out = new ObjectOutputStream(new BufferedOutputStream(
                        s.getOutputStream()));
                // log.debug("got the output stream");
                soc.out.flush();
                // log.debug("output stream flushed");
                soc.in = new ObjectInputStream(new BufferedInputStream(
                        s.getInputStream()));
                // log.debug("got the input stream");
                synchronized (unreadSockets) {
                    unreadSockets.add(soc);
                }
                // log.debug("Socket has been enqueued.");
            } catch (Exception e) {
                // log.debug("Some error:", e);
            }
        }
    }

    /**
     * @return the number of waiting priority requests
     */
    public int getNumberOfWaitingPriorityRequests() {
        synchronized (priorityRequests) {
            return priorityRequests.size();
        }
    }

    /**
     * @return the number of non-priority requests
     */
    public int getNumberOfWaitingNonPriorityRequests() {
        synchronized (requests) {
            return requests.size();
        }
    }

    /**
     * @return the number of waiting responses
     */
    public int getNumberOfWaitingResponses() {
        synchronized (responses) {
            return responses.size();
        }
    }

    /**
     * @return the number of open connections
     */
    public int getNumberOfWaitingClients() {

        synchronized (waitingSockets) {
            return waitingSockets.size();
        }
    }

    /**
     * @return the number of open connections
     */
    public int getNumberOfUnreadClients() {
        synchronized (unreadSockets) {
            return unreadSockets.size();
        }
    }

    class ThreadScaleManager extends Thread {

        /*
         * (non-Javadoc)
         *
         * @see java.lang.Thread#run()
         */
        @Override
        public void run() {
            log.info("ThreadScaleManager is now running.");
            super.run();
            ArrayList<RequestHandlerThread> handlerthreads = new ArrayList<Receiver.RequestHandlerThread>();
            ArrayList<NetworkIOHandler> networkthreads = new ArrayList<Receiver.NetworkIOHandler>();
            int currentNets = numberOfNetworkIOHandlers / 2, currentHandles = numberOfRequestHandlers / 2;
            int sizenet = 0, sizehandler = 0, lastsizenet = 0, lastsizehandler = 0;
            // start threads
            for (int i = 0; i < numberOfRequestHandlers; i++) {
                RequestHandlerThread reqhan = new RequestHandlerThread();
                if (i == 0 || i < numberOfRequestHandlers / 2)
                    reqhan.active = true;
                reqhan.start();
                handlerthreads.add(reqhan);
            }
            log.info("Started " + numberOfRequestHandlers
                    + " RequestHandlerThreads.");
            for (int i = 0; i < numberOfNetworkIOHandlers; i++) {
                NetworkIOHandler netio = new NetworkIOHandler();
                if (i == 0 || i < numberOfNetworkIOHandlers / 2)
                    netio.active = true;
                netio.start();
                networkthreads.add(netio);
            }
            log.info("Started " + numberOfNetworkIOHandlers
                    + " NetworkIOHandlerThreads.");
            while (!isInterrupted()) {
                // sleep until next check
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
                    this.interrupt();
                }
                // check whether the balance between thread numbers is okay
                synchronized (requests) {
                    sizehandler = requests.size();
                }
                synchronized (priorityRequests) {
                    sizehandler += priorityRequests.size();
                }
                synchronized (unreadSockets) {
                    sizenet = unreadSockets.size();
                }
                synchronized (responses) {
                    sizenet += responses.size();
                }
                // check network io
                if (sizenet > 1 + lastsizenet
                        && currentNets <= numberOfNetworkIOHandlers) {
                    // scale up by 1 (queues more than one larger)
                    int counter = 0;
                    for (NetworkIOHandler n : networkthreads) {
                        if (counter++ < currentNets + 1)
                            n.active = true;
                        else
                            n.active = false;
                    }
                    currentNets++;
                } else if (sizenet + 1 < lastsizenet && currentNets > 1) {
                    // scale down by 1 (queues more than one shorter)
                    int counter = 0;
                    for (NetworkIOHandler n : networkthreads) {
                        if (counter++ < currentNets + -1)
                            n.active = true;
                        else
                            n.active = false;
                    }
                    currentNets--;
                } else {
                    // cannot do anything because there was either less than two
                    // entries change in queue length or we are either at 1 or
                    // numberOfNetworkIOHandlers threads running
                }
                // check handlers
                if (sizehandler > 1 + lastsizehandler
                        && currentHandles < numberOfRequestHandlers) {
                    // scale up by 1 (queues more than one larger)
                    int counter = 0;
                    for (RequestHandlerThread r : handlerthreads) {
                        if (counter++ < currentHandles + 1)
                            r.active = true;
                        else
                            r.active = false;
                    }
                    currentHandles++;
                } else if (sizehandler + 1 < lastsizehandler
                        && currentHandles > 1) {
                    // scale down by 1 (queues more than one shorter)
                    int counter = 0;
                    for (RequestHandlerThread r : handlerthreads) {
                        if (counter++ < currentHandles + -1)
                            r.active = true;
                        else
                            r.active = false;
                    }
                    currentHandles--;
                } else {
                    // cannot do anything because there was either less than two
                    // entries change in queue length or we are either at 1 or
                    // numberOfRequestHandlers threads running
                }
                // scaling done
                lastsizenet = sizenet;
                lastsizehandler = sizehandler;
                // log
                log.info("Now active: \n- " + currentNets + " out of "
                        + numberOfNetworkIOHandlers
                        + " NetworkHandlerThreads\n- " + currentHandles
                        + " out of " + numberOfRequestHandlers
                        + " RequestHandlerThreads\nQueue status:\n- "
                        + getNumberOfWaitingPriorityRequests()
                        + " priority requests waiting\n- "
                        + getNumberOfWaitingNonPriorityRequests()
                        + " normal requests waiting\n- "
                        + getNumberOfWaitingResponses()
                        + " responses waiting\n- "
                        + getNumberOfWaitingClients() + " clients waiting\n- "
                        + getNumberOfUnreadClients() + " clients unread");
            }

        }
    }

    /**
     * invokes the handlers
     *
     * @author David Bermbach
     *         <p>
     *         created on: 24.04.2012
     */
    class RequestHandlerThread extends Thread {

        private boolean active = false;

        /*
         * (non-Javadoc)
         *
         * @see java.lang.Thread#run()
         */
        @Override
        public void run() {
            super.run();
            while (!isInterrupted()) {
                Request req = null;
                Integer reqid = null;
                try {
                    // check if this thread is active
                    if (!active) {
                        try {
                            Thread.sleep(5000);
                            continue;
                        } catch (InterruptedException e) {
                            break;
                        }
                    }
                    synchronized (priorityRequests) {
                        reqid = priorityRequests.poll();
                    }
                    if (reqid == null)
                        synchronized (requests) {
                            reqid = requests.poll();
                        }

                    // log.debug("Got request id: " + reqid);
                    if (reqid == null)
                        continue;

                    // got a request
                    boolean containsmapping = false;
                    synchronized (unhandledRequests) {
                        containsmapping = unhandledRequests.containsKey(reqid);
                        req = unhandledRequests.remove(reqid);
                    }
                    if (req == null) {
                        log.error("GOT A NULL REQUEST!!! (RequestHandlerThread.run), reqid="
                                + reqid
                                + ", map contained "
                                + (containsmapping ? "a null mapping "
                                : "no mapping ")
                                + "for the specified req id.");
                        // should never happen
                        continue;
                    }
                    log.debug("Handler lookup for request id "
                            + req.getRequestId() + " at "
                            + new Date().getTime());
                    // everything ok
                    IRequestHandler handler = RequestHandlerRegistry
                            .getInstance().getHandlerForID(req.getTarget());
                    Response resp = handler.handleRequest(req);
                    // log.debug("Request handled.");
                    if (resp == null && !handler.requiresResponse()) {
                        // we're done
                        continue;
                    } else if (resp != null && handler.requiresResponse()) {
                        // send response
                        synchronized (waitingResponses) {
                            waitingResponses.put(reqid, resp);
                        }
                        synchronized (responses) {
                            responses.add(reqid);
                        }
                        log.debug(
                                "Response for request id "
                                        + req.getRequestId()
                                        + " enqueued at "
                                        + new Date().getTime());

                    } else {
                        // handler implementation breaks the contract of
                        // only (but always) returning null when
                        // requiresResponse() returns false!!!
                        // -> should never happen, do nothing but logging
                        log.error("Class " + handler.getClass().getSimpleName()
                                + " breaks the contract specified in the"
                                + " interface IRequestHandler");
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                    Response resp = new Response("An error occurred ("
                            + e.getClass().getSimpleName() + "): "
                            + e.getMessage(), false, req);
                    synchronized (waitingResponses) {
                        waitingResponses.put(reqid, resp);
                    }
                    synchronized (responses) {
                        responses.add(reqid);
                    }
                }
            }
        }

    }

    /**
     * reads and writes from and to sockets
     *
     * @author David Bermbach
     *         <p>
     *         created on: 24.04.2012
     */
    class NetworkIOHandler extends Thread {

        private boolean active = false;
        private SocketPackage soc;

        private boolean addingComplete = true;

        /*
         * (non-Javadoc)
         *
         * @see java.lang.Thread#run()
         */
        @Override
        public void run() {
            super.run();
            while (!isInterrupted()) {
                try {
                    // check if this thread is active
                    if (!active) {
                        try {
                            Thread.sleep(5000);
                            continue;
                        } catch (InterruptedException e) {
                            this.interrupt();
                        }
                    }
                    // this thread is active
                    // check for unread sockets
                    tryRequests();
                    // check for completed requests
                    tryResponses();
                } catch (Exception e) {
                    e.printStackTrace();
                    log.error("Exception in NetworkIOHandler.run()", e);
                }
            }
        }

        private void tryResponses() {
            // check for completed requests
            Integer reqid = null;
            Response resp = null;
            synchronized (responses) {
                if (responses.size() > 0)
                    reqid = responses.remove();
            }
            if (reqid == null)
                return;
            // got a request id (i.e. some response)
            synchronized (waitingResponses) {
                resp = waitingResponses.remove(reqid);
            }
            synchronized (waitingSockets) {
                soc = waitingSockets.remove(reqid);
            }
            respond(resp);
        }

        private void tryRequests() throws Exception {
            if (!addingComplete)
                log.error("adding was not complete!");
            boolean priorityRequest = false;
            // check for unread sockets
            synchronized (unreadSockets) {
                soc = unreadSockets.poll();
            }
            if (soc == null)
                return;
            // log.debug("Dequeued a socket!");
            if (soc.socket != null) {
                // log.debug("Got a socket with streams, now reading.");
                String conn = null;
                String connectionAddress = soc.socket.getInetAddress().getHostAddress() + " (conn.id=" + soc.hashCode() + ")";
                log.debug("Start reading from connection " + connectionAddress + " at "
                        + new Date().getTime());
                Request req = readFromSocket();
                if (req == null) {
                    closeSession();
                    return;
                }
                log.debug("Created request with timestamp "
                        + req.getTimestamp().getTime()
                        + " (req.id=" + req.getRequestId()
                        + ", conn.id=" + soc.hashCode() + ")");
                // log.debug("Finished reading request.");
                // check whether response is possible right away
                int hash = req.hashCode();
                try {
                    if (!RequestHandlerRegistry.getInstance()
                            .getHandlerForID(req.getTarget())
                            .requiresResponse()) {
                        // respond right away with an o.k.
                        respond(new Response(SUCCESS, true, req));
                        // log.debug("Sending success right away as no response is required.");
                        priorityRequest = RequestHandlerRegistry.getInstance()
                                .getHandlerForID(req.getTarget()).hasPriority();
                        addingComplete = false;
                        synchronized (unhandledRequests) {
                            unhandledRequests.put(hash, req);
                        }
                        if (priorityRequest) {
                            synchronized (priorityRequests) {
                                priorityRequests.add(hash);
                            }
                        } else {
                            synchronized (requests) {
                                requests.add(hash);
                            }
                        }
                        addingComplete = true;
                        return;
                    }
                } catch (NullPointerException e) {
                    // target unknown
                    respond(new Response(NO_HANDLER_FOUND, false, req));
                    log.info("No handler was found for request target "
                            + req.getTarget());
                    return;
                }
                // log.debug("Enqueueing request...");
                // response is not possible right away but we got a
                // handler
                // -> put in queue and move socket to waitingSockets
                synchronized (waitingSockets) {
                    waitingSockets.put(hash, soc);
                }
                addingComplete = false;
                synchronized (unhandledRequests) {
                    unhandledRequests.put(hash, req);
                }
                if (priorityRequest) {
                    synchronized (priorityRequests) {
                        priorityRequests.add(hash);
                    }
                } else {
                    synchronized (requests) {
                        requests.add(hash);
                    }
                }

                addingComplete = true;
                // log.debug("Request enqueued.");
            }
        }

        /**
         * @return null if an error occurred
         */
        private Request readFromSocket() {
            try {
                Request req = null;
                int n = (Integer) soc.in.readObject(); // number of items
                // log.debug("Read number of items:" + n);
                String target = (String) soc.in.readObject(); // target handler
                // log.debug("Read target:" + target);
                String messageid = (String) soc.in.readObject(); // message id
                String originator = (String) soc.in.readObject(); // originator
                List<Serializable> res = new ArrayList<Serializable>(n);
                // log.debug("Finished reading header.");
                if (n == 0) {
                    req = new Request(res, target, messageid, null);
                } else {
                    // read items
                    for (int i = 0; i < n; i++) {
                        Object o = soc.in.readObject();
                        res.add((Serializable) o);
                    }
                    req = new Request(res, target, messageid, null);
                    req.setOriginator(originator);
                }
                // log.debug("Finished reading body, enqueueing socket package.");
                // log.debug("Request was:\n" + req);
                return req;
            } catch (Exception e) {
                e.printStackTrace();
                closeSession(); // drop socket if not able to read request
                return null;
            }
        }

        /**
         * responds to the client and closes the current session
         *
         * @param resp
         */
        private void respond(Response resp) {
            String connectionAddress = "";
            try {
                connectionAddress = soc.socket.getInetAddress().getHostAddress() + " (req.id=" + resp.getRequestId() + ", conn.id="
                        + soc.hashCode() + ")";
                log.debug(
                        "Starting response on connection " + connectionAddress + " at "
                                + new Date().getTime());

                soc.out.writeObject(resp.getItems().size());
                soc.out.flush();
                soc.out.writeObject(resp.responseCode());
                soc.out.flush();
                soc.out.writeObject(resp.getResponseMessage());
                soc.out.flush();
                soc.out.writeObject(resp.getRequestId());
                soc.out.flush();
                for (Serializable s : resp.getItems()) {
                    soc.out.writeObject(s);
                    soc.out.flush();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            closeSession();
            log.debug(
                    "Completed response on connection " + connectionAddress + " at "
                            + new Date().getTime());
        }

        /**
         * closes the current session, will never throw an exception
         */
        private void closeSession() {
            try {
                soc.socket.close();
            } catch (Exception e) {
            }
            soc.socket = null;
            soc.in = null;
            soc.out = null;
            soc = null;
            // log.debug("Session closed.");
        }

    }

}
